---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/12/14 12:00
---

local _format = string.format

LogLevel = LogLevel or {
    DEBUG = 1,
    INFO = 2,
    WARNING = 3,
    ERROR = 4,
    FATAL = 5
}
Log = Log or {}
if _G.LOGLEVEL then
    Log.Level = _G.LOGLEVEL
    -- else
    --     Log.Level = import("LogFunctionLibrary").GetLogLevel()
end
if not Log.Level then
    Log.Level = 1
end

-- luacheck: push ignore
local function stringFormat(prefix, msg, ...)
    -- fix by C7
    local level = 5
    local info = debug.getinfo(level, "Sl")
    local name = info.source:match( "([^/]+)$" )
    local filename = string.gsub(name, "?.*", "")

    local sTable = {}
    sTable[#sTable + 1] = filename:match("([^/\\]+)$")
    sTable[#sTable + 1] = ': Line '
    sTable[#sTable + 1] = info.currentline
    sTable[#sTable + 1] = '. '
    if type(msg) == "table" then
        sTable[#sTable+1] = tostring(msg)
    else
        if select("#",...)>0 then
            sTable[#sTable + 1] = string.format(msg, ...)
        else
            sTable[#sTable + 1] = msg
        end
    end
    return table.concat(sTable)
    -- fix by C7 end
end


-- fix by C7
local function stringConcat(prefix, msg, ...)
    local level = 5
    local info = debug.getinfo(level, "Sl")
    local name = info.source:match( "([^/]+)$" )
    local filename = string.gsub(name, "?.*", "")

    local sTable = {}
    sTable[#sTable + 1] = filename:match("([^/\\]+)$")
    sTable[#sTable + 1] = ': Line '
    sTable[#sTable + 1] = info.currentline
    sTable[#sTable + 1] = '. '
    sTable[#sTable + 1] = tostring(msg)
    for i = 1, select("#",...) do
        sTable[#sTable + 1] = ' '
        sTable[#sTable + 1] = tostring(select(i,...))
    end
    sTable[#sTable + 1] = ' '
    return table.concat(sTable)
end

-- luacheck: pop

-- if not ReleaseLog then
--     function DebugLog(...)
--         print("Info:", ...)
--     end

--     function DebugLogWarning(...)
--         print("Warning:", ...)
--     end

--     function DebugLogError(...)
--         print("Error:", ...)
--     end

--     function ReleaseLog(...)
--         print("Info:", ...)
--     end

--     function ReleaseLogWarning(...)
--         print("Warning:", ...)
--     end

--     function ReleaseLogError(...)
--         print("Error:", ...)
--     end

--     function ReleaseQueryLog(rpcName)
--         print("BOT_QUERY|"..os.time().."|"..rpcName)
--     end
-- end
-- fix by C7 end


---@class Logger
DefineClass("Logger")

function Logger:ctor(prefix)
    self.prefix = prefix or ""
end

function Logger:SetPrefix(prefix)
    self.prefix = prefix
end

function Logger:Debug(msg, ...)
    if Log.Level > LogLevel.DEBUG then
        return
    end
    self:printLog(DebugLog, msg, ...)
end

function Logger:DebugWarning(msg, ...)
    if Log.Level > LogLevel.WARNING then
        return
    end
    self:printLog(DebugLogWarning, msg, ...)
end

function Logger:DebugError(msg, ...)
    if Log.Level > LogLevel.ERROR then
        return
    end
    self:printLogTrace(DebugLogError, msg, ...)
end

function Logger:Release(msg, ...)
    self:printLog(ReleaseLog, msg, ...)
end

function Logger:ReleaseWarning(msg, ...)
    self:printLog(ReleaseLogWarning, msg, ...)
end

function Logger:ReleaseError(msg, ...)
    self:printLogTrace(ReleaseLogError, msg, ...)
end

function Logger:printLog(logFunc, msg, ...)
    local ok, ret = xpcall(stringFormat, _G.CallBackError, self.prefix, msg, ...)
    if ok then
        logFunc(ret)
    end
end
function Logger:printLogTrace(logFunc, msg, ...)
    local ok, ret = xpcall(stringFormat,_G.CallBackError, self.prefix, msg, ...)
    if ok then
        logFunc(debug.traceback(ret,3))
    end
end


-- fix by C7
function Logger:printLogConcat(logFunc, msg, ...)
    local ok, ret = pcall(stringConcat, self.prefix, msg, ...)
    if ok then
        logFunc(ret)
    else
        print("Log Error, err: "..ret.."\n"..debug.traceback())
    end
end
function Logger:printLogConcatTrace(logFunc, msg, ...)
    local ok, ret = pcall(stringConcat, self.prefix, msg, ...)
    if ok then
        logFunc(debug.traceback(ret, 3))
    else
        print("Log Error, err: "..ret.."\n"..debug.traceback())
    end
end

Log.Debug = function(msg, ...)
    if Log.Level > LogLevel.DEBUG then
        return
    end
    Game.Logger:printLogConcat(DebugLog, msg, ...)
end
Log.DebugFormat = function(msg, ...)
    if Log.Level > LogLevel.DEBUG then
        return
    end
    Game.Logger:printLog(DebugLog, msg, ...)
end

Log.Info = function(msg, ...)
    if Log.Level > LogLevel.INFO then
        return
    end
    Game.Logger:printLogConcat(DebugInfo, msg, ...)
end
Log.InfoFormat = function(msg, ...)
    if Log.Level > LogLevel.INFO then
        return
    end
    Game.Logger:printLog(DebugInfo, msg, ...)
end

Log.Warning = function(msg, ...)
    if Log.Level > LogLevel.WARNING then
        return
    end
    Game.Logger:printLogConcat(DebugLogWarning, msg, ...)
end
Log.WarningFormat = function(msg, ...)
    if Log.Level > LogLevel.WARNING then
        return
    end
    Game.Logger:printLog(DebugLogWarning, msg, ...)
end

Log.Error = function(msg, ...)
    if Log.Level > LogLevel.ERROR then
        return
    end
    Game.Logger:printLogConcatTrace(DebugLogError, msg, ...)
end
Log.ErrorFormat = function(msg, ...)
    if Log.Level > LogLevel.ERROR then
        return
    end
    Game.Logger:printLogTrace(DebugLogError, msg, ...)
end

Log.Fatal = function(msg, ...)
    if Log.Level > LogLevel.FATAL then
        return
    end
    Game.Logger:printLogConcatTrace(DebugLogFatal, msg, ...)
end
Log.FatalFormat = function(msg, ...)
    if Log.Level > LogLevel.FATAL then
        return
    end
    Game.Logger:printLogTrace(DebugLogFatal, msg, ...)
end

local function DumpTable(Table, Dump_metatable, Max_level)
    if not Table then
        return
    end
    local lookup_table = {}

    local rep = string.rep

    Dump_metatable = Dump_metatable or false

    Max_level = Max_level or 1

    local function _dump(t, level)
        local str = "\n" .. rep("\t", level) .. "{\n"

        for k, v in pairs(t) do
            local k_is_str = type(k) == "string" and 1 or 0

            local v_is_str = type(v) == "string" and 1 or 0

            str =
                str ..
                rep("\t", level + 1) ..
                    "[" .. rep('"', k_is_str) .. (tostring(k) or type(k)) .. rep('"', k_is_str) .. "]" .. " = "

            if type(v) == "table" then
                if not lookup_table[v] and ((not Max_level) or level < Max_level) then
                    lookup_table[v] = true

                    str = str .. _dump(v, level + 1) .. "\n"
                else
                    str = str .. (tostring(v) or type(v)) .. ",\n"
                end
            else
                str = str .. rep('"', v_is_str) .. (tostring(v) or type(v)) .. rep('"', v_is_str) .. ",\n"
            end
        end

        if Dump_metatable then
            local mt = getmetatable(t)

            if mt ~= nil and type(mt) == "table" then
                str = str .. rep("\t", level + 1) .. '["__metatable"]' .. " = "

                if not lookup_table[mt] and ((not Max_level) or level < Max_level) then
                    lookup_table[mt] = true

                    str = str .. _dump(mt, level + 1) .. "\n"
                end
            end
        end

        str = str .. rep("\t", level) .. "},"

        return str
    end

    print(string.sub(_dump(Table, 0), 1, -2))
end

Log.Dump = function(Table, Dump_metatable, Max_level)
    if Log.Level > LogLevel.DEBUG then
        return
    end
    DumpTable(Table, Dump_metatable, Max_level)
end

Log.Traceback = function(thread, msg, level)
    if Log.Level > LogLevel.DEBUG then
        return
    end
    debug.traceback(thread, msg, level)
end

Log.SetLevel = function(Level)
    Log.Level = Level
end

Log.IsLogLevelEnable = function(Level)
    return Log.Level <= Level
end

if USE_LUA_CLOGGER then
    Log.Debug = LuaCLogger.Log
    Log.DebugFormat = LuaCLogger.LogFmt
    Log.Info = LuaCLogger.Log
    Log.InfoFormat = LuaCLogger.LogFmt
    Log.Warning = LuaCLogger.Warn
    Log.WarningFormat = LuaCLogger.WarnFmt
    Log.Error = LuaCLogger.Error
    Log.ErrorFormat = LuaCLogger.ErrorFmt
end

-- 客户端和服务器的Log接口保持一致，用于Shared目录中的代码
LOG_DEBUG = Log.Debug
LOG_DEBUG_FMT = Log.DebugFormat
LOG_INFO = Log.Info
LOG_INFO_FMT = Log.InfoFormat
LOG_WARN = Log.Warning
LOG_WARN_FMT = Log.WarningFormat
LOG_ERROR = Log.Error
LOG_ERROR_FMT = Log.ErrorFormat

-- 游戏开始时输出当前日志等级
local FinishInit = function()
    for key, v in pairs(LogLevel) do
        if v == Log.Level then
            local sTable = {}
            sTable[#sTable + 1] = "Current LogLevel is: "
            sTable[#sTable + 1] = tostring(key)
            DebugLog(table.concat(sTable))
            break
        end
    end
end

FinishInit()

-- fix by C7 end
