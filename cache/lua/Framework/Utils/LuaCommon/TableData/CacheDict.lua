---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2022/3/2 12:55
---
---缓存dict，维持maxCacheSize指定的缓存空间，超出就pop lru k
---@class CacheDict
---@field maxCacheSize number > 0
---@field createFunc function
---@field releaseFunc function|nil
---@field _data table cached data, k to data
---@field _score table score data, k to {accessTime, priority}
---@field _count number cur cache size
DefineClass("CacheDict")

CacheDict.ScoreIndex = {   -- luacheck:ignore
    Access = 1,
    Priority = 2,
}

function CacheDict:ctor(maxCacheSize, createFunc, releaseFunc)
    self.maxCacheSize = maxCacheSize
    self.createFunc = createFunc
    self.releaseFunc = releaseFunc or function(k) self:defaultReleaseFunc(k) end
    self._data = {}
    self._score = {}
    self._count = 0
end

function CacheDict:dtor()
    self:ReleaseAll()
    self.createFunc = nil
    self.releaseFunc = nil
    self._data = {}
    self._count = 0
end

---获取k对应的数据
function CacheDict:RawGet(k)
    return self._data[k]
end

---获取k对应的数据
---@param k
---@param priority number|nil 优先级
function CacheDict:GetOrCreate(k, priority)
    if self._data[k] ~= nil then
        self:onHit(k, priority)
        return self._data[k]
    end
    self:onMiss(k, priority)
    return self._data[k]
end

---释放k对应的数据, 默认删除k
function CacheDict:Release(k)
    self._count = self._count - 1
    self.releaseFunc(k)
end

---仅删除k值，不释放缓存
function CacheDict:Remove(k)
    self._data[k] = nil
    self._score[k] = nil
end

---释放所有数据
function CacheDict:ReleaseAll()
    for k, _ in pairs(self._data) do  -- todo delete when pairs
        self:Release(k)
    end
end

---按照LRU原则，释放指定数量的数据
function CacheDict:ReleaseLRU(num)
    local keys = {}
    for k, _ in pairs(self._data) do
        keys[#keys + 1] = k
    end
    table.sort(keys, function(a, b) return self:compScore(a, b) end)
    local releaseCount = math.min(num, #keys)
    for idx=1, releaseCount do
        self:Release(keys[idx])
    end
end

---获取cache的数量
function CacheDict:Size()
    return self._count
end

function CacheDict:onHit(k, priority)
    self:onAccess(k, priority)
end

function CacheDict:onMiss(k, priority)
    if self.maxCacheSize > 0 and self._count >= self.maxCacheSize then
        -- 释放一个槽位
        local popK = self:GetMinKey(self._score, nil, 
                function(a, b) return self:compScore(a, b)  end)
        self:Release(popK)
    end
    self._data[k] = self.createFunc(k)
    self._score[k] = {}
    self:onAccess(k, priority)
    self._count = self._count + 1
end

function CacheDict:onAccess(k, priority)
    -- c7 fix start
    local ScoreIndex = CacheDict.ScoreIndex
    -- self._score[k][ScoreIndex.Access] = Time.realtimeSinceStartup
    self._score[k][ScoreIndex.Access] = os.time()
    -- c7 fix start
    if priority ~= nil then
        self._score[k][ScoreIndex.Priority] = priority
    end
end

function CacheDict:defaultReleaseFunc(k)
    self._data[k] = nil
    self._score[k] = nil
end

--- return true if a is smaller
function CacheDict:compScore(a, b)
    --comp priority, return true if a is lower or a is nil
    local scoreB = self._score[b]
    local scoreA = self._score[a]
    local ScoreIndex = CacheDict.ScoreIndex
    if scoreB[ScoreIndex.Priority] ~= scoreA[ScoreIndex.Priority] then
        -- a is nil or a < b
        if scoreA[ScoreIndex.Priority] == nil then
            return true
        else
            if scoreB[ScoreIndex.Priority] == nil then
                return false
            else
                if scoreA[ScoreIndex.Priority] < scoreB[ScoreIndex.Priority] then
                    return true
                end
            end
        end
        -- b is nil or b < a
        return false
    end
    
    --comp access time, will not be nil, return true if a is earlier
    return scoreA[ScoreIndex.Access] < scoreB[ScoreIndex.Access]
end

---@private 获取输入dict的最小key值
---@param dictInputs table dict
---@param keyFunc  function|nil 计算key的函数, input k, return key
---@param compareFunc function|nil 比较函数，input key1, key2, output boolean, return true if key1 is smaller
function CacheDict:GetMinKey(dictInputs, keyFunc, compareFunc)
    keyFunc = keyFunc or CacheDict.defaultKeyFunc
    compareFunc = compareFunc or CacheDict.defaultCompareFunc
    local minKey
    for k, _ in pairs(dictInputs) do
        if minKey == nil or compareFunc(keyFunc(k), keyFunc(minKey)) then
            minKey = k
        end
    end
    return minKey
end


---@private defaultKeyFunc
function CacheDict.defaultKeyFunc(a)
    return a
end

---@private 默认的比较函数, return true if a is smaller
function CacheDict.defaultCompareFunc(a, b)
    if b ~= nil then
        -- b not nil and a is nil
        if a == nil then
            return true
        end
        -- b is larger than a
        if b > a then
            return true
        end
    end
end

return CacheDict