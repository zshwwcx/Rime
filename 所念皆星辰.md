# Python

## 装饰器
最近想提高一下代码质量，发现高阶python编程的第一个建议就是善用装饰器，所以就过来研究一下装饰器相关的东西了。之前也看过很多遍，但总是看完就会，就觉得很好用，到用的时候又总是容易忘，然后又懒得去查，然后就懒得再用了。

这次长记性了，把一些常用的和不常用的装饰器用法都记录下来，下次使用的时候直接查一下markdown日志，也强迫自己多用，这样才能慢慢提高代码质量。

### 装饰器的理解
装饰器wrapper本质是重写func，返回一个包含原函数func功能的新的函数对象，但函数的名称、参数什么的都不会发生变化。对装饰器的理解能够加深python一切皆对象的理念。
```
@deco
def func():
   xxxx 
```
等价于:
```
def func():
    xxxx
func = deco(func)
```
在给func套上装饰器@deco之后，原先的func就消失了，func被deco(func)取代。如果希望保留原先func这样一个对象的话，有一种方式，在装饰器返回的对象中添加一个成员函数，用来存储你想要保存的原函数func对象:
```
def deco(func):
    def inner():
        xxx
    inner._f = func
    return inner

@deco
def func():
    xxx
```


### 常用装饰器
最普通的装饰器，看代码就行

```python
def wrapper(func):
    def inner():
        print "before inner func()."
        func()
        print "after inner func()."
    inner._f = func # 将func函数保存在wrapper内，保证需要的时候，可以通过func._f()来调用
    return inner


@wrapper
def foo():
    print "hello world."
```

### 上下文装饰器(contextlib decorator)
```python
#todo: 这个看过，也理解了一些内容，但是实际上一次都没用过。等真正遇到使用场景再来填这个坑吧
```


## 魔术方法(magic methods)


## 一些奇怪的小技巧

### 字符串反向处理
将字符串a进行反转
```python
a = '!dlrow olleH'

b = a[::-1]
# result:  b = 'Hello world!'
```

### 智能开箱
一种比较酷的解压缩列表的方法
```python3(python2不支持这种方式)
a, *b, c = [1,2,3,4,5]

a = 1
b = [2, 3, 4]
c = 5
```

### 各种推导式

#### 列表推导式
使用[]生成list
```fake_code
variable = [out_exp_res for out_exp in input_list if out_exp == 2]
```
例子:
```python
list1 = [i for i in range(30) if i % 3 == 1]


def double(i):
    return 2 * i
list2 = [double(i) for i in range(20) if i % 3 == 0]
```

#### 字典推导
```python
d = {x: x % 2 == 0 for x in range(1, 11) }
```
