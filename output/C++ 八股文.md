# C++ 八股文

## 语言基础

### 1.1.1 C++语言的特点

1. C++在C语言的基础上引入了面向对象的机制，同时也兼容C语言
2. C++有三大特性： 封装、 继承、 多态
3. 由于对面对象的机制，C++写出的程序结构清晰、易于扩充，可读性很好
4. C++生成的代码质量高，运行效率高，仅仅比汇编语言慢10%~20%
5. C++更加安全，增加了const常量、引用、四类cast转换(static_cast, dynamic_cast, const_cast, reinterpret_cast)、智能指针、try-catch等等
6. C++可复用性更高，有模板机制的存在，STL库
7. C++11引入了nullptr, auto变量，Lambda匿名函数，右值引用，智能指针等feature。

### 1.1.3 说说C++中struct和class的区别

### 1.1.4 说说include头文件的顺序以及双引号""和尖括号<>的区别
1. 区别
   （1） 尖括号<>的头文件是系统文件，双引号""的文件是自定义文件。
   （2） 编译器预处理阶段查找头文件的路径不一样。
2.  查找路径
   （1） 使用尖括号<>的头文件查找路径：编译器设置的头文件路径--> 系统变量。
   （2） 使用双引号""的头文件查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

### 1.1.7 简述C++从代码到可执行二进制文件的过程

C++和C语言类似，一个C++程序从源码到执行文件，有四个过程:预编译、编译、汇编、链接。

1. 预编译:
   （1） 将所有的#define删除，并且展开所有的宏定义
   （2） 处理所有的条件预编译指令，如#if #ifdef  
   （3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置
   （4） 过滤所有的注释
   （5） 添加行号和文件名标识
2. 编译
   （1） 词法分析:将源代码的字符序列分割成一系列的记号
   （2） 语法分析：对记号进行语法分析，产生
   （3） 语义分析：判断表达式是否有意义
   （4） 代码优化
   （5） 目标代码生成:生成汇编语言
   （6） 目标代码优化
3. 汇编：将汇编代码转变为机器可以执行的指令
4. 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。
    链接分为静态链接和动态链接。
    静态链接：在链接的时候就已经将需要调用的函数/过程链接到了生成的可执行文件中，就算在链接后将静态库删除也不会影响可执行程序的执行；静态链接库在windows系统下为.lib后缀，在Linux下是.a后缀
    动态链接：在链接的时候把没有调用的函数代码链接进去，而是在执行的过程中，去寻找要链接的函数，生成的可执行文件中没有函数代码，只包含了函数的重定位信息，所以删除动态库会导致程序无法运营； 动态库在windows系统下为.dll后缀，在Linux系统下是.so后缀。

### 1.1.8 说说static关键字的作用

1. 定义全局静态变量和局部静态变量: 在变量前面加上static关键字。 初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。全局静态变量和局部静态变量的作用域不同，其他无差异。
2. 定义静态函数：再函数返回类型前加上static关键字，函数即被定义为静态函数。静态函数只能在本源文件中使用
3. static定义类中的成员变量:使用静态数据成员，它可以被当成全局变量纯纯，同时又被隐藏在类的内部。 类中的static静态数据成员拥有一块单独的存储区，而不管创建了多少个该类的对象。所有这些对象的静态数据成员都共享这一块静态存储空间。
4. static定义类中的静态成员函数:和静态成员变量类似，静态成员函数也是类的一部分，而不是对象的一部分，所有对象的静态数据成员都共享这一块静态存储空间。

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。 而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针。 因为它没有指向某一个对象，也就无法对一个对象中的非静态成员进行访问。

### 1.1.11 静态变量什么时候初始化

C++的全局/静态对象当且仅当对象的首次使用才进行构造

1.作用域: C++里面作用域可以分为6种: 全局、局部、类、语句、命名空间和文件作用域
    静态全局变量: 全局作用域+文件作用域， 所以无法在其他文件中使用
    静态局部变量: 局部作用域，只被初始化一次，直到程序结束
    类静态成员变量: 类作用域
2.所在空间: 
    都在静态存储区。
3.生命周期:
    静态全局变量、静态局部变量都在静态存储区，直到程序结束才会被回收。
    类静态成员变量在静态存储区，当超出类作用域时回收内存。

### 1.1.12 nullptr可以调用成员函数吗？
可以， 因为在编译对象的时候就已经绑定了函数地址，和指针是否为空无关。

### 1.1.13 什么是野指针，怎么产生的，如何避免
1.概念： 野指针就是指针指向的位置是不可知的
2.产生原因： 释放内存后指针不及时质控，依然指向了该内存，那么就可能出现非法访问的错误。
3.避免办法：
（1） 初始化置NULL
（2） 申请内存后判空
（3） 指针释放后置NULL
（4） 使用智能指针

### 1.1.17 说说new和malloc的区别，各自底层的实现原理

1.区别:
(1) new是操作符，malloc是函数
(2) new在调用的时候先分配内存，再调用构造函数，释放的时候调用析构函数。 malloc没有构造函数和析构函数。
(3) malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。
(4) new可以被重载； malloc不行
(5) new分配内存更直接和安全
(6) new发生错误抛出异常， malloc返回null

2.实现原理

(1) malloc底层实现:
当开辟的内存空间小于128K时，调用brk()函数；当开辟的内存空间大于128K时，调用mmap()。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区氛围多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块进行链接，每一个空闲块记录了一个未分配的、连续的内存地址。

(2) new底层实现：
[1] 创建一个新的对象
[2] 将构造函数的作用域赋值给这个新的对象(this指向了这个新的对象)
[3] 执行构造函数中的代码
[4] 返回新对象


## C++内存

### 1.2.1 简述下堆和栈的区别

1. 堆栈空间分配不同。 栈由操作系统(编译器)自动分配释放，存放函数的参数值、局部变量等； 堆一般由程序员分配和释放
2. 堆栈缓存方式不同。 栈使用的是一级缓存，它们通常是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些
3. 堆栈数据结构不同。 堆类似于数组结构；栈则是标准栈结构，先进后出。

### 1.2.2 简述C++的内存管理

(1) 内存分配方式

C++中的内存分为五大区，分别是：

栈区（Stack）
栈区是由编译器自动分配和释放的内存区域，用于存储函数的局部变量、函数参数和返回值等。栈区的内存分配和释放由编译器自动管理，不需要手动控制。栈区的内存空间较小，分配和释放速度较快，但不能动态地分配和释放，只能按照先进后出的顺序进行访问。

堆区（Heap）
堆区是由程序员手动分配和释放的内存区域，通常用于存储动态分配的数据结构和对象。堆区的内存分配和释放由程序员自行控制，可以使用new、delete等运算符进行分配和释放。堆区的内存空间较大，可以动态地分配和释放，但需要手动管理，容易出现内存泄漏和内存泄漏等问题。

全局区（Global）
全局区是由编译器自动分配和释放的内存区域，用于存储全局变量、静态变量和常量等。全局区的内存分配和释放由编译器自动管理，其生命周期与程序的运行周期相同，即在程序运行期间始终存在，直到程序结束才会被释放。

常量区（Constant）
常量区是由编译器自动分配和释放的内存区域，用于存储常量字符串和全局常量等。常量区的内存分配和释放由编译器自动管理，其生命周期与程序的运行周期相同，即在程序运行期间始终存在，直到程序结束才会被释放。

栈顶区（Stack Top）
栈顶区是栈区的顶部，用于存储函数调用的返回地址和一些系统级别的数据。栈顶区的内存分配和释放由编译器自动管理，不需要手动控制。


### 1.2.3 malloc和局部变量分配在堆还是栈上

malloc是在堆上分配内存，需要程序员自己回收；局部变量是在栈中分配内存，超过作用域自动回收。

### 1.2.6 什么是内存泄漏，内存泄漏如何检查

内存泄漏是指程序在运行过程中分配的内存空间没有被释放，导致内存空间的浪费和程序性能的下降。内存泄漏通常是由程序员编写的代码中存在错误或不当的内存管理方式导致的。

下面介绍几种常见的检查内存泄漏的方法：

静态分析工具
静态分析工具可以在编译时或运行时检查代码中的内存泄漏问题。常见的静态分析工具包括Valgrind、Purify、Coverity等。这些工具可以检查代码中的内存分配和释放操作，找出未释放的内存空间，并给出相应的提示和建议。

动态分析工具
动态分析工具可以在程序运行时检查内存泄漏问题。常见的动态分析工具包括LeakSanitizer、AddressSanitizer、Electric Fence等。这些工具可以跟踪程序运行时的内存分配和释放操作，找出未释放的内存空间，并给出相应的提示和建议。

手动检查
程序员可以手动检查代码中的内存分配和释放操作，找出未释放的内存空间。可以使用一些工具，如内存分析器、调试器等，来帮助定位内存泄漏问题。程序员也可以在代码中添加一些调试信息，如打印内存分配和释放操作的日志，来帮助定位内存泄漏问题。

总之，内存泄漏是一种常见的程序错误，需要程序员注意内存管理和安全性问题，避免出现内存泄漏和内存溢出等问题。可以使用静态分析工具、动态分析工具或手动检查等方法来检查内存泄漏问题。

### 1.2.9 简述C++中内存对齐的使用场景

什么是内存对齐？

那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，编译器为结构体的每个成员按其自然边界（alignment）分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

为什么要字节对齐？

需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。


## 面向对象

### 1.3.2 面向对象的三大特征

封装、继承和多态

1. 封装： 将数据和操作数据的方法进行有机结合， 隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互。 封装的本质是一种管理:将可控的接口暴露给外部，将隐私的数据保护起来。

2. 继承: 可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

3. 多态： 用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。 实现多态有两种方式: 重写，重载

### 1.3.22 纯虚函数可以实例化吗？ 派生类需要实现吗？

1.纯虚函数不可以实例化，但是可以用其派生类实例化

2.虚函数的原理采用 vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。
即“纯虚函数在类的vtable表中对应的表项被赋值为0。也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。” 所以纯虚函数不能实例化。

3.纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。

4.定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

### 1.3.23 C++虚函数和纯虚函数的区别

1. 虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类被称为抽象类，只含有虚函数的类不能称为抽象类。
2. 虚函数可以被直接使用，也可以被子类重载以后，以多态的形式调用，而纯虚函数必须在子类中实现该函数才可以使用，因为纯虚函数在基类有声明而没有定义。
3. 虚函数和纯虚函数都可以在子类中被重载，以多态的形式被调用。
4. 虚函数和纯虚函数通常存在于抽象基类之中，被继承的子类重载，目的是提供一个统一的接口
5. 虚函数的定义形式: virtual {}; 纯虚函数的定义形式: virtual {}=0; 在虚函数和纯虚函数的定义中不能有static标志符，原因在于:被static修饰的函数在编译时要求前期绑定，而虚函数却是动态绑定的，被两者修饰的函数生命周期也不一样。

### 1.3.24 C++菱形继承问题，如何解决

虚继承

虚继承是C++中的一种特殊的继承方式，用于解决多重继承中的菱形继承问题。菱形继承是指一个派生类同时继承自两个基类，而这两个基类又共同继承自一个基类，从而形成了一个菱形的继承关系。菱形继承会导致派生类中包含两份相同的基类成员，从而浪费内存空间和增加程序的复杂度。

虚继承通过在继承关系中使用关键字virtual来解决菱形继承问题。虚继承可以使得派生类中只包含一份共同基类的成员，从而节省内存空间和简化程序的设计。

### 1.3.25 构造函数中能否调用虚函数

可以，但没必要

### 1.3.26 拷贝构造函数的参数是什么传递方式

1. 拷贝构造函数的参数必须使用引用传递
2. 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相党羽采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。

### 1.3.28 如何理解抽象类

1. 抽象类的定义:
    纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。 在基类中实现纯虚函数的方法是在函数原型后加"=0"，有纯虚函数的类就叫做抽象类。
2. 抽象类的特点：
   1) 抽象类只能用作其他类的基类，不能进行实例化
   2) 抽象类不能用作参数类型、函数返回类型或显式转换的类型
   3) 可以定义指向抽象类的指针和引用，此指针可以指向它的派生类，进而实现多态

### 1.3.29 什么是多态？ 除了虚函数，还有什么方式可以实现多态

1. 多态是面向对象的重要特性之一，它是一种行为的封装，不同对象对同一行为会有不同的状态.
2. 多态是以封装和继承为基础的。在C++中多态氛围静态多态（早绑定）和动态多态（晚绑定）两种，其中动态多态是通过虚函数实现，静态多态通过函数重载实现。

### 1.3.30 虚析构函数是什么，它有什么作用

C++中的虚析构函数是一种特殊的析构函数，用于在删除对象时正确地释放对象的内存空间。虚析构函数的作用主要有以下两个方面：

```保证正确的析构顺序```
在C++中，如果一个类中包含有其他类的对象或指针，那么在删除该类的对象时，需要先删除这些对象或指针，然后再删除该类的对象。如果不正确地处理析构顺序，可能会导致内存泄漏或程序崩溃等问题。

虚析构函数可以保证正确的析构顺序，即先调用派生类的析构函数，再调用基类的析构函数。这是因为在使用delete运算符删除一个指向派生类对象的基类指针时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致派生类的资源无法正确释放。而如果基类的析构函数是虚函数，那么在使用delete运算符删除一个指向派生类对象的基类指针时，会先调用派生类的析构函数，再调用基类的析构函数，从而保证正确的析构顺序。

```支持多态性```
在C++中，如果一个类中包含有虚函数，那么通常需要将该类的析构函数定义为虚析构函数。这是因为如果一个类的析构函数不是虚函数，那么在使用delete运算符删除一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致派生类的资源无法正确释放。而如果一个类的析构函数是虚函数，那么在使用delete运算符删除一个指向派生类对象的基类指针时，会先调用派生类的析构函数，再调用基类的析构函数，从而保证正确的析构顺序和多态性。

因此，虚析构函数在C++中具有重要的作用，可以保证正确的析构顺序和多态性，从而提高程序的稳定性和可维护性。

### 1.3.32 拷贝赋值和移动赋值

1. 拷贝赋值是通过拷贝构造函数来赋值，在创建对象时，使用同一个类中之前创建的对象来初始化新的对象。
2. 移动赋值是通过移动构造函数来赋值，二者的主要区别在于
    1） 拷贝构造函数的形参是一个左值引用，移动构造函数的形参是一个右值引用
    2） 拷贝构造函数完成的是整个对象/变量的拷贝，而移动构造函数是生成一个指针指向源对对象/变量的地址，接管原对象的内存，相对于大量数据的拷贝节省时间和内存空间

### 1.3.33 仿函数了解吗？有什么作用

C++中的仿函数（Functor）是一种重载了函数调用运算符()的类，可以像函数一样被调用。仿函数可以用于STL中的算法和容器等，提供了一种灵活的方式来实现自定义的操作。

仿函数通常包括以下几个部分：

类型定义
仿函数通常需要定义一个类，用于重载函数调用运算符()。类的定义可以包括构造函数、析构函数和其他成员函数等。

函数调用运算符重载
仿函数需要重载函数调用运算符()，以实现类似函数的调用方式。函数调用运算符可以包括一个或多个参数，用于接收调用时传递的参数。函数调用运算符可以返回一个值，用于表示仿函数的执行结果。

例如，以下是一个简单的仿函数示例：

```
class Add {
public:
    int operator()(int a, int b) {
        return a + b;
    }
};
上述代码中，定义了一个名为Add的仿函数类，重载了函数调用运算符()，用于实现两个整数的加法操作。在使用该仿函数时，可以像调用函数一样使用它，例如：


Add add;
int result = add(1, 2); // result = 3
仿函数可以用于STL中的算法和容器等，例如：

vector<int> v = {1, 2, 3, 4, 5};
transform(v.begin(), v.end(), v.begin(), Add()(1, 2));
上述代码中，使用STL中的transform算法和Add仿函数，将容器v中的每个元素加上1和2，并将结果存储回容器v中。
```

需要注意的是，仿函数可以是有状态的，即可以包含成员变量和成员函数等，从而实现更加复杂的操作。在使用仿函数时，需要根据具体的需求来定义和实现仿函数。

### 1.3.34 C++中哪些函数不能被声明为虚函数

常见的不不能声明为虚函数的有：普通函数（非成员函数），静态成员函数，内联成员函数，构造函数，友元函数。

(总结下就是不具有多态属性的，都不能被声明为虚函数)

```为什么C++不支持普通函数为虚函数？```

普通函数（非成员函数）只能被overload，不能被override，声明为虚函数也没有什么意思，因此编译器会在编译时绑定函数。

```为什么C++不支持构造函数为虚函数？```

这个原因很简单，主要是从语义上考虑，所以不支持。因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。（这不就是典型的悖论）

构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以不能将构造函数定义为虚函数

```为什么C++不支持内联成员函数为虚函数？```

其实很简单，那内联函数就是为了在代码中直接展开，减少函数调用花费的代价，虚函数是为了在继承后对象能够准确的执行自己的动作，这是不可能统一的。（再说了，inline函数在编译时被展开，虚函数在运行时才能动态的绑定函数）

内联函数是在编译时期展开,而虚函数的特性是运行时才动态联编,所以两者矛盾,不能定义内联函数为虚函数

```为什么C++不支持静态成员函数为虚函数？```

这也很简单，静态成员函数对于每个类来说只有一份代码，所有的对象都共享这一份代码，他也没有要动态绑定的必要性。

静态成员函数属于一个类而非某一对象,没有this指针,它无法进行对象的判别

```为什么C++不支持友元函数为虚函数？```

因为C++不支持友元函数的继承，对于没有继承特性的函数没有虚函数的说法。

### 1.3.35 C++中模板和模板类的区别

1. 类模板是模板的定义，不是一个实际的类，定义中用到通用类型参数
2. 模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型所替代

### 1.3.36 虚函数表里面的内容是什么时候写进去的

虚函数表（Virtual Function Table，简称VTable）是C++中实现多态性的一种机制，用于存储类的虚函数地址。虚函数表中存放的内容是在编译期间就确定的，即在编译时就已经将虚函数表的内容写入到可执行文件中。

在C++中，每个类都有一个虚函数表，其中存放了该类的虚函数地址。当一个类被继承时，派生类会继承基类的虚函数表，并在其中添加自己的虚函数地址。当使用基类指针或引用调用派生类对象的虚函数时，会根据对象的实际类型在虚函数表中查找对应的虚函数地址，并调用该函数。

虚函数表的内容是在编译期间就确定的，因为在编译时编译器已经知道每个类的虚函数地址，并将其写入到可执行文件中。在程序运行时，虚函数表的内容不会发生改变，因此虚函数表的内容是静态的。

需要注意的是，不同的编译器可能会对虚函数表的实现方式有所不同，因此在使用虚函数时需要注意编译器的兼容性。


## STL

### 1.4.2 STL中常见的容器，并介绍下实现原理

STL（Standard Template Library）是C++标准库中的一个重要组成部分，提供了一系列的容器、算法和迭代器等，用于实现常见的数据结构和算法。STL中常见的容器包括以下几种：

```vector```
vector是一种动态数组，可以在尾部快速添加和删除元素，支持随机访问和迭代器等。vector的实现原理是使用连续的内存空间存储元素，当元素数量超过当前容量时，会重新分配更大的内存空间，并将原有元素复制到新的内存空间中。

```list```
list是一种双向链表，可以在任意位置快速添加和删除元素，支持迭代器等。list的实现原理是使用双向链表存储元素，每个节点包含指向前驱和后继节点的指针。

```deque```
deque是一种双端队列，可以在头部和尾部快速添加和删除元素，支持随机访问和迭代器等。deque的实现原理是使用多个连续的内存块存储元素，每个内存块包含固定数量的元素，当元素数量超过当前内存块的容量时，会分配新的内存块，并将原有元素复制到新的内存块中。

```set```
set是一种集合，可以存储不重复的元素，并支持快速查找、插入和删除等操作，支持迭代器等。set的实现原理是使用红黑树存储元素，保证元素按照一定的顺序排列，并支持快速查找、插入和删除等操作。

```map```
map是一种关联数组，可以存储键值对，并支持快速查找、插入和删除等操作，支持迭代器等。map的实现原理是使用红黑树存储键值对，保证键按照一定的顺序排列，并支持快速查找、插入和删除等操作。

以上是STL中常见的容器，它们的实现原理都是基于不同的数据结构实现的。在使用STL容器时，需要根据具体的需求选择合适的容器，并了解其实现原理，以便更好地使用和优化容器的性能。

### 1.4.x 什么是红黑树

红黑树（Red-Black Tree）是一种自平衡二叉查找树，它是一种特殊的二叉查找树，具有以下特点：

```
1.每个节点要么是红色，要么是黑色。

2.根节点是黑色的。

3.每个叶子节点（NIL节点，空节点）是黑色的。

4.如果一个节点是红色的，则它的两个子节点都是黑色的。

5.对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。
```

红黑树的自平衡性是通过对节点进行颜色变换和旋转操作来实现的。当插入或删除节点时，可能会破坏红黑树的平衡性，此时需要对树进行调整，使其重新满足红黑树的性质。

红黑树的优点是在最坏情况下，基本操作的时间复杂度为O(log n)，其中n为树中节点的数量。因此，红黑树被广泛应用于C++ STL中的set和map等容器的实现中。

需要注意的是，红黑树并不是唯一的自平衡二叉查找树，还有其他的自平衡二叉查找树，如AVL树、Treap树等。在实际应用中，需要根据具体的需求选择合适的自平衡二叉查找树。

### 1.4.9 说说STL中resize和reserve的区别

```首先必须弄清楚两个概念：```

（1）capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素的个数。还不能通过下标等访问，因为此时容器中还没有创建任何对象。

（2）size：指的是此时容器中实际的元素个数。可以通过下标访问0-(size-1)范围内的对象。

```resize和reserve区别主要有以下几点：```

（1）resize既分配了空间，也创建了对象；reserve表示容器预留空间，但并不是真正的创建对象，需要通过insert（）或push_back（）等创建对象。

（2）resize既修改capacity大小，也修改size大小；reserve只修改capacity大小，不修改size大小。

（3）两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

### 1.4.11 说说map和unordered_map的区别？底层实现

```map实现机理```

map内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此map内部所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

```unordered_map实现机理```

unordered_map内部实现了一个哈希表（也叫散列表），通过把关键码值映射到Hash表中一个位置来访问记录，查找时间复杂度可达O（1），其中在海量数据处理中有着广泛应用。因此，元素的排列顺序是无序的。

### 1.4.17 说说push_back和emplace_back的区别

如果要将一个临时变量push到容器的末尾，push_back()需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。

## 新特性

### 1.5.1 说说C++11的新特性有哪些

1. 语法的改进

```统一的初始化方法```

```成员变量默认初始化```
构建一个类对象不需要用构造函数初始化成员变量

```auto关键字```
用于定义变量，编译器可以自动判断类型(前提：变量定义的时候需要初始化)

```decltype```
求表达式类型。 decltype是C++11新增的一个关键字，它和auto一样，都是用来在编译器进行自动类型推导

Q:为什么要有decltype?

因为auto不适用于所有的自动类型推导场景，在某些特殊情况下 auto使用非常不方便，甚至压根无法使用。

```
auto varname= value;

decltype (exp) varname = value;
```

其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。

decltype 可以写成下面的形式：

```
decltype (exp) 变量名;
```

```智能指针```

C++11引入了智能指针（Smart Pointer）的概念，它是一种RAII（Resource Acquisition Is Initialization）技术的实现，用于管理动态分配的内存资源，避免内存泄漏和悬空指针等问题。

C++11中提供了三种智能指针：unique_ptr、shared_ptr和weak_ptr。

unique_ptr：是一种独占式智能指针，它拥有对动态分配的内存资源的唯一所有权，不能被复制或共享。当unique_ptr被销毁时，它所拥有的内存资源也会被自动释放。

shared_ptr：是一种共享式智能指针，它可以被多个shared_ptr对象共享同一个动态分配的内存资源。每个shared_ptr对象都维护一个引用计数，当引用计数为0时，内存资源会被自动释放。

weak_ptr：是一种弱引用智能指针，它可以指向一个由shared_ptr管理的内存资源，但不会增加引用计数。当所有的shared_ptr对象都被销毁时，weak_ptr也会自动失效。

使用智能指针可以避免手动管理动态分配的内存资源，从而提高代码的可读性和可维护性。需要注意的是，智能指针并不能完全解决内存管理的问题，仍然需要根据具体的场景进行选择和使用。

```空指针nullptr```

nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。

```基于范围的for循环```

C++11引入了基于范围的for循环（Range-based for loop），它是一种简化的循环语法，用于遍历容器中的元素。

基于范围的for循环的语法格式如下：

```
for (auto& element : container) {
    // 循环体
}
```

其中，element是容器中的元素，container是要遍历的容器，auto关键字用于自动推导element的类型。在循环体中，可以使用element访问容器中的元素。

基于范围的for循环可以遍历支持迭代器的容器，包括数组、vector、list、set、map等STL容器，以及自定义的容器类型。需要注意的是，基于范围的for循环只能用于遍历容器中的元素，不能用于遍历数组或其他类型的数据结构。

基于范围的for循环的优点是简洁、易读，可以避免手动管理迭代器的复杂性和错误。在实际应用中，建议优先使用基于范围的for循环来遍历容器中的元素。

```右值引用和移动语义```

2. 标准库扩充

```无序容器(哈希表)```

用法和功能和map完全一样，区别在于哈希表的效率更高。

包含四种不同的容器: unordered_map, unordered_multimap, unordered_set, unordered_multiset

```正则表达式```

```Lambda表达式```

匿名函数， 可以套用如下的语法格式

```
[capture list] (parameter list) mutable noexcept/throw() -> return type { function body }
```

a. []方括号用于向编译器标明当前是一个lambda表达式，其不能被省略。 在方括号内部，可以注明当前lambda函数需要使用哪些外部变量。

b. (参数) 和普通函数一样， 如果不需要参数， ()可以省略

c. mutable 可省略，如果使用则前面的()不可省略(参数个数可以为0)。 默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。

d. noexcept/throw() 可省略，如果使用则前面的()不可省略。 默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。

e. -> 返回值类型 指明 lambda函数的返回值类型。 如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"。

f. 函数体 function body; 


### 1.5.2 说说C++智能指针和指针的区别

```智能指针```
如果在程序中使用new从堆中分配内存，等到不需要时，应使用delete将其释放。 C++引用了智能指针，以帮助自动完成这个过程。

```指针```
C语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。

```区别```
智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。

### 1.5.11 简述下C++11中四种类型转换

```const_cast```

C++中的const_cast是一种类型转换运算符，用于将const或volatile限定符从指针或引用类型中移除。const_cast的语法如下：


```
const_cast<new_type>(expression)
```

其中，new_type是要转换成的类型，expression是要转换的表达式。const_cast可以用于以下几种情况：

将const指针或引用转换为非const指针或引用：

```
const int* p = &x;
int* q = const_cast<int*>(p);
```
将volatile指针或引用转换为非volatile指针或引用：

```
volatile int* p = &x;
int* q = const_cast<int*>(p);
```
将const volatile指针或引用转换为非const volatile指针或引用：

```
const volatile int* p = &x;
int* q = const_cast<int*>(p);
```
需要注意的是，const_cast只能用于移除const或volatile限定符，不能用于添加限定符。如果试图将非const指针或引用转换为const指针或引用，应该使用static_cast或reinterpret_cast。

另外，使用const_cast需要谨慎，因为它可以破坏const或volatile的语义，可能会导致未定义的行为。在使用const_cast时，应该确保被转换的对象实际上是可修改的，否则可能会导致程序崩溃或者产生不可预测的结果。

```static_cast```
static_cast用于基本数据类型之间的转换，以及具有继承关系的指针或引用之间的转换。它可以将一个指针或引用转换为另一个指针或引用，但不进行运行时类型检查，因此转换不安全。

```
int x = 10;
double y = static_cast<double>(x); // 将int类型的x转换为double类型的y

class Base {};
class Derived : public Base {};
Base* b = new Derived;
Derived* d = static_cast<Derived*>(b); // 将Base类型的指针b转换为Derived类型的指针d
```

```dynamic_cast```
dynamic_cast用于具有继承关系的指针或引用之间的转换，它进行运行时类型检查，可以检查转换是否安全。如果转换不安全，则返回空指针或引用。

```
class Base {
public:
    virtual void foo() {}
};
class Derived : public Base {};

Base* b = new Derived;
Derived* d = dynamic_cast<Derived*>(b); // 将Base类型的指针b转换为Derived类型的指针d
if (d != nullptr) {
    d->foo();
}
```

```reinterpret_cast```
可以做任何类型的转换，不过不对转换结果做保证，容易出问题

## 设计模式

### 1.6.1 用C++实现一个单例模式

1. static 变量:天然的单例
2. 设计代码:

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    void doSomething() {
        // do something
    }

private:
    Singleton() {} // 构造函数私有化，防止外部实例化
    Singleton(const Singleton&) = delete; // 禁止拷贝构造函数
    Singleton& operator=(const Singleton&) = delete; // 禁止赋值运算符

    // 其他私有成员变量和函数
};

int main() {
    Singleton& instance = Singleton::getInstance();
    instance.doSomething();
    return 0;
}
```

在上面的示例代码中，Singleton类的构造函数被私有化，这意味着外部无法直接实例化该类。getInstance()函数是一个静态函数，用于获取Singleton类的唯一实例。在getInstance()函数中，使用了静态局部变量的方式来创建Singleton类的唯一实例，这保证了该实例只会被创建一次。由于getInstance()函数返回的是Singleton类的引用，因此外部可以通过该引用来访问Singleton类的公共成员函数和变量。

需要注意的是，为了防止外部通过拷贝构造函数或赋值运算符来创建Singleton类的新实例，我们需要将这两个函数禁止掉。这可以通过将拷贝构造函数和赋值运算符声明为private，并将其实现删除来实现。

## 数据结构和算法

### 1.7.1 说说红黑树和AVL树的定义、特点，以及二者的区别

```平衡二叉树(AVL树)```

以树中所有节点为根的树的左右子树高度差的绝对值不超过1。

AVL树的平衡是通过旋转操作来实现的。当插入或删除节点后，如果AVL树不再平衡，就需要进行旋转操作来重新平衡。AVL树的旋转操作包括左旋和右旋两种操作，它们可以保持树的平衡，并且不会破坏二叉搜索树的性质。

AVL树的时间复杂度比较稳定，插入、删除和查找操作的时间复杂度都是O(log n)，其中n是树中节点的数量。因此，AVL树适用于需要频繁插入、删除和查找节点的场景，例如数据库索引、编译器符号表等。

需要注意的是，AVL树的平衡是以牺牲一定的空间为代价的。AVL树需要为每个节点存储平衡因子，以记录左右子树的高度差。因此，AVL树的空间复杂度比较高，通常比红黑树等其他自平衡二叉搜索树要高。

总之，AVL树是一种自平衡二叉搜索树，它通过旋转操作来保持树的平衡，并且具有稳定的时间复杂度。在实际应用中，可以根据具体的场景选择合适的数据结构，以满足不同的需求。

```红黑树```

红黑树是一种自平衡二叉搜索树，它的名称来自节点的颜色，每个节点要么是红色，要么是黑色。红黑树的特点是保持树的高度平衡，即任何节点到叶子节点的路径上，黑色节点的数量相同。

红黑树的平衡是通过节点的颜色和旋转操作来实现的。红黑树的节点有两种颜色，黑色和红色。红黑树的节点满足以下性质：

根节点是黑色的。

每个叶子节点都是黑色的空节点（NIL节点）。

如果一个节点是红色的，则它的两个子节点都是黑色的。

从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。

当插入或删除节点后，如果红黑树不再平衡，就需要进行旋转操作来重新平衡。红黑树的旋转操作包括左旋和右旋两种操作，它们可以保持树的平衡，并且不会破坏二叉搜索树的性质。

红黑树的时间复杂度比较稳定，插入、删除和查找操作的时间复杂度都是O(log n)，其中n是树中节点的数量。因此，红黑树适用于需要频繁插入、删除和查找节点的场景，例如STL中的map和set等容器。

需要注意的是，红黑树的平衡是以牺牲一定的空间为代价的。红黑树需要为每个节点存储颜色信息，以记录节点的颜色。因此，红黑树的空间复杂度比较高，通常比AVL树等其他自平衡二叉搜索树要高。

总之，红黑树是一种自平衡二叉搜索树，它通过节点的颜色和旋转操作来保持树的平衡，并且具有稳定的时间复杂度。在实际应用中，可以根据具体的场景选择合适的数据结构，以满足不同的需求。

```区别```

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。

